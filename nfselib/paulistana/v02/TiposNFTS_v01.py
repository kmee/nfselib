#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Wed Jul 22 06:40:30 2020 by generateDS.py version 2.30.15.
# Python 3.8.3 (default, May 17 2020, 18:15:42)  [GCC 10.1.0]
#
# Command line options:
#   ('--no-namespace-defs', '')
#   ('--no-collect-includes', '')
#   ('--use-getter-setter', 'none')
#   ('-f', '')
#   ('-o', './paulistanalib/v02/TiposNFTS_v01.py')
#
# Command line arguments:
#   ./process_includes/TiposNFTS_v01.xsd
#
# Command line:
#   /home/mileo/Projects/oca12/bin/erpbrasil-edoc-gen-generate-python --no-namespace-defs --no-collect-includes --use-getter-setter="none" -f -o "./paulistanalib/v02/TiposNFTS_v01.py" ./process_includes/TiposNFTS_v01.xsd
#
# Current working directory (os.getcwd()):
#   schemas
#

import os
import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    try:
        if isinstance(infile, os.PathLike):
            infile = os.path.join(infile)
    except AttributeError:
        pass
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for an example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#
# Additionally, the generatedsnamespaces module can contain a python
# dictionary named GenerateDSNamespaceTypePrefixes that associates element
# types with the namespace prefixes that are to be added to the
# "xsi:type" attribute value.  See the exportAttributes method of
# any generated element type and the generation of "xsi:type" for an
# example of the use of this table.
# An example table:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceTypePrefixes = {
#         "ElementtypeC": "aaa:",
#         "ElementtypeD": "bbb:",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}
try:
    from generatedsnamespaces import GenerateDSNamespaceTypePrefixes as GenerateDSNamespaceTypePrefixes_
except ImportError:
    GenerateDSNamespaceTypePrefixes_ = {}

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (
                    time_parts[0], "{}".format(micro_seconds).rjust(6, "0"), )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.items()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            if type(self) != type(other):
                return False
            return self.__dict__ == other.__dict__
        def __ne__(self, other):
            return not self.__eq__(other)
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = ''
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name_=name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class tpOpcaoSimples(object):
    _0='0'
    _1='1'
    _2='2'
    _3='3'


class tpStatusNFe(object):
    N='N'
    C='C'
    E='E'


class tpTipoRPS(object):
    RPS='RPS'
    RPSM='RPS-M'
    RPSC='RPS-C'


class tpStatusNFTS(object):
    N='N'
    C='C'


class tpTipoDocumentoNFTS(object):
    _0_1='01'
    _0_2='02'
    _0_3='03'
    _0_5='05'


class tpTributacaoNFTS(object):
    T='T'
    I='I'
    J='J'


class tpEvento(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Codigo=None, Descricao=None, IdentificacaoDocumento=None, IdentificacaoNFTS=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.Codigo = Codigo
        self.validate_tpCodigoEvento(self.Codigo)
        self.Descricao = Descricao
        self.validate_tpDescricaoEvento(self.Descricao)
        self.IdentificacaoDocumento = IdentificacaoDocumento
        self.IdentificacaoNFTS = IdentificacaoNFTS
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpEvento)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpEvento.subclass:
            return tpEvento.subclass(*args_, **kwargs_)
        else:
            return tpEvento(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_tpCodigoEvento(self, value):
        # Validate type tpCodigoEvento, a restriction on xs:int.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_tpCodigoEvento_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpCodigoEvento_patterns_, ))
    validate_tpCodigoEvento_patterns_ = [['^[0-9]{3,4}$']]
    def validate_tpDescricaoEvento(self, value):
        # Validate type tpDescricaoEvento, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 300:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpDescricaoEvento' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tpDescricaoEvento' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Codigo is not None or
            self.Descricao is not None or
            self.IdentificacaoDocumento is not None or
            self.IdentificacaoNFTS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tpEvento', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpEvento')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='tpEvento')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='tpEvento', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='tpEvento'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tpEvento', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Codigo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCodigo>%s</%sCodigo>%s' % (namespaceprefix_ , self.gds_format_integer(self.Codigo, input_name='Codigo'), namespaceprefix_ , eol_))
        if self.Descricao is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDescricao>%s</%sDescricao>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Descricao), input_name='Descricao')), namespaceprefix_ , eol_))
        if self.IdentificacaoDocumento is not None:
            self.IdentificacaoDocumento.export(outfile, level, namespaceprefix_, namespacedef_='', name_='IdentificacaoDocumento', pretty_print=pretty_print)
        if self.IdentificacaoNFTS is not None:
            self.IdentificacaoNFTS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='IdentificacaoNFTS', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Codigo' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Codigo')
            self.Codigo = ival_
            # validate type tpCodigoEvento
            self.validate_tpCodigoEvento(self.Codigo)
        elif nodeName_ == 'Descricao':
            Descricao_ = child_.text
            Descricao_ = self.gds_validate_string(Descricao_, node, 'Descricao')
            self.Descricao = Descricao_
            # validate type tpDescricaoEvento
            self.validate_tpDescricaoEvento(self.Descricao)
        elif nodeName_ == 'IdentificacaoDocumento':
            obj_ = tpIdentificacaoDocumento.factory(parent_object_=self)
            obj_.build(child_)
            self.IdentificacaoDocumento = obj_
            obj_.original_tagname_ = 'IdentificacaoDocumento'
        elif nodeName_ == 'IdentificacaoNFTS':
            obj_ = tpIdentificacaoNFTS.factory(parent_object_=self)
            obj_.build(child_)
            self.IdentificacaoNFTS = obj_
            obj_.original_tagname_ = 'IdentificacaoNFTS'
# end class tpEvento


class tpInformacoesLoteNFTS(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, NumeroLote=None, Remetente=None, dtEnvioLote=None, QtdeNFTSProcessadas=None, TempoProcessamento=None, ValorTotalServicos=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.NumeroLote = NumeroLote
        self.validate_tpNumeroLote(self.NumeroLote)
        self.Remetente = Remetente
        if isinstance(dtEnvioLote, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(dtEnvioLote, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = dtEnvioLote
        self.dtEnvioLote = initvalue_
        self.QtdeNFTSProcessadas = QtdeNFTSProcessadas
        self.validate_tpQuantidade(self.QtdeNFTSProcessadas)
        self.TempoProcessamento = TempoProcessamento
        self.validate_tpTempoProcessamento(self.TempoProcessamento)
        self.ValorTotalServicos = ValorTotalServicos
        self.validate_tpValor(self.ValorTotalServicos)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpInformacoesLoteNFTS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpInformacoesLoteNFTS.subclass:
            return tpInformacoesLoteNFTS.subclass(*args_, **kwargs_)
        else:
            return tpInformacoesLoteNFTS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_tpNumeroLote(self, value):
        # Validate type tpNumeroLote, a restriction on xs:nonNegativeInteger.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 15:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on tpNumeroLote' % {"value" : value} )
    def validate_tpQuantidade(self, value):
        # Validate type tpQuantidade, a restriction on xs:long.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_tpQuantidade_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpQuantidade_patterns_, ))
    validate_tpQuantidade_patterns_ = [['^[0-9]{1,15}$']]
    def validate_tpTempoProcessamento(self, value):
        # Validate type tpTempoProcessamento, a restriction on xs:long.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_tpTempoProcessamento_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpTempoProcessamento_patterns_, ))
    validate_tpTempoProcessamento_patterns_ = [['^[0-9]{1,15}$']]
    def validate_tpValor(self, value):
        # Validate type tpValor, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on tpValor' % {"value" : value} )
            if len(str(value)) >= 15:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on tpValor' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_tpValor_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpValor_patterns_, ))
    validate_tpValor_patterns_ = [['^0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{0,2})?$']]
    def hasContent_(self):
        if (
            self.NumeroLote is not None or
            self.Remetente is not None or
            self.dtEnvioLote is not None or
            self.QtdeNFTSProcessadas is not None or
            self.TempoProcessamento is not None or
            self.ValorTotalServicos is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tpInformacoesLoteNFTS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpInformacoesLoteNFTS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='tpInformacoesLoteNFTS')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='tpInformacoesLoteNFTS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='tpInformacoesLoteNFTS'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tpInformacoesLoteNFTS', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.NumeroLote is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNumeroLote>%s</%sNumeroLote>%s' % (namespaceprefix_ , self.gds_format_integer(self.NumeroLote, input_name='NumeroLote'), namespaceprefix_ , eol_))
        if self.Remetente is not None:
            self.Remetente.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Remetente', pretty_print=pretty_print)
        if self.dtEnvioLote is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdtEnvioLote>%s</%sdtEnvioLote>%s' % (namespaceprefix_ , self.gds_format_datetime(self.dtEnvioLote, input_name='dtEnvioLote'), namespaceprefix_ , eol_))
        if self.QtdeNFTSProcessadas is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sQtdeNFTSProcessadas>%s</%sQtdeNFTSProcessadas>%s' % (namespaceprefix_ , self.gds_format_integer(self.QtdeNFTSProcessadas, input_name='QtdeNFTSProcessadas'), namespaceprefix_ , eol_))
        if self.TempoProcessamento is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTempoProcessamento>%s</%sTempoProcessamento>%s' % (namespaceprefix_ , self.gds_format_integer(self.TempoProcessamento, input_name='TempoProcessamento'), namespaceprefix_ , eol_))
        if self.ValorTotalServicos is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sValorTotalServicos>%s</%sValorTotalServicos>%s' % (namespaceprefix_ , self.gds_format_float(self.ValorTotalServicos, input_name='ValorTotalServicos'), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NumeroLote' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'NumeroLote')
            self.NumeroLote = ival_
            # validate type tpNumeroLote
            self.validate_tpNumeroLote(self.NumeroLote)
        elif nodeName_ == 'Remetente':
            obj_ = tpRemetente.factory(parent_object_=self)
            obj_.build(child_)
            self.Remetente = obj_
            obj_.original_tagname_ = 'Remetente'
        elif nodeName_ == 'dtEnvioLote':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.dtEnvioLote = dval_
        elif nodeName_ == 'QtdeNFTSProcessadas' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'QtdeNFTSProcessadas')
            self.QtdeNFTSProcessadas = ival_
            # validate type tpQuantidade
            self.validate_tpQuantidade(self.QtdeNFTSProcessadas)
        elif nodeName_ == 'TempoProcessamento' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'TempoProcessamento')
            self.TempoProcessamento = ival_
            # validate type tpTempoProcessamento
            self.validate_tpTempoProcessamento(self.TempoProcessamento)
        elif nodeName_ == 'ValorTotalServicos' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'ValorTotalServicos')
            self.ValorTotalServicos = fval_
            # validate type tpValor
            self.validate_tpValor(self.ValorTotalServicos)
# end class tpInformacoesLoteNFTS


class tpCabecalho(GeneratedsSuper):
    """Cabeçalho do retorno.Informe a Versão do Schema XML utilizado."""
    subclass = None
    superclass = None
    def __init__(self, Versao=None, Sucesso=None, InformacoesLoteNFTS=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.Versao = _cast(int, Versao)
        self.Sucesso = Sucesso
        self.validate_tpSucesso(self.Sucesso)
        self.InformacoesLoteNFTS = InformacoesLoteNFTS
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpCabecalho)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpCabecalho.subclass:
            return tpCabecalho.subclass(*args_, **kwargs_)
        else:
            return tpCabecalho(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_tpSucesso(self, value):
        # Validate type tpSucesso, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Sucesso is not None or
            self.InformacoesLoteNFTS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tpCabecalho', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpCabecalho')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='tpCabecalho')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='tpCabecalho', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='tpCabecalho'):
        if self.Versao is not None and 'Versao' not in already_processed:
            already_processed.add('Versao')
            outfile.write(' Versao=%s' % (quote_attrib(self.Versao), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tpCabecalho', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Sucesso is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSucesso>%s</%sSucesso>%s' % (namespaceprefix_ , self.gds_format_boolean(self.Sucesso, input_name='Sucesso'), namespaceprefix_ , eol_))
        if self.InformacoesLoteNFTS is not None:
            self.InformacoesLoteNFTS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='InformacoesLoteNFTS', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Versao', node)
        if value is not None and 'Versao' not in already_processed:
            already_processed.add('Versao')
            self.Versao = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Sucesso':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'Sucesso')
            self.Sucesso = ival_
            # validate type tpSucesso
            self.validate_tpSucesso(self.Sucesso)
        elif nodeName_ == 'InformacoesLoteNFTS':
            obj_ = tpInformacoesLoteNFTS.factory(parent_object_=self)
            obj_.build(child_)
            self.InformacoesLoteNFTS = obj_
            obj_.original_tagname_ = 'InformacoesLoteNFTS'
# end class tpCabecalho


class tpCabecalhoRetorno(GeneratedsSuper):
    """Cabeçalho do retorno para consultas.Informe a Versão do Schema XML
    utilizado."""
    subclass = None
    superclass = None
    def __init__(self, Versao='1', Sucesso=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.Versao = _cast(int, Versao)
        self.Sucesso = Sucesso
        self.validate_tpSucesso(self.Sucesso)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpCabecalhoRetorno)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpCabecalhoRetorno.subclass:
            return tpCabecalhoRetorno.subclass(*args_, **kwargs_)
        else:
            return tpCabecalhoRetorno(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_tpSucesso(self, value):
        # Validate type tpSucesso, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Sucesso is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tpCabecalhoRetorno', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpCabecalhoRetorno')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='tpCabecalhoRetorno')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='tpCabecalhoRetorno', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='tpCabecalhoRetorno'):
        if self.Versao != 1 and 'Versao' not in already_processed:
            already_processed.add('Versao')
            outfile.write(' Versao=%s' % (quote_attrib(self.Versao), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tpCabecalhoRetorno', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Sucesso is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSucesso>%s</%sSucesso>%s' % (namespaceprefix_ , self.gds_format_boolean(self.Sucesso, input_name='Sucesso'), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Versao', node)
        if value is not None and 'Versao' not in already_processed:
            already_processed.add('Versao')
            self.Versao = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Sucesso':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'Sucesso')
            self.Sucesso = ival_
            # validate type tpSucesso
            self.validate_tpSucesso(self.Sucesso)
# end class tpCabecalhoRetorno


class tpListaRetornoLote(GeneratedsSuper):
    """Lista de mensagens de retorno do lote"""
    subclass = None
    superclass = None
    def __init__(self, Alerta=None, Erro=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if Alerta is None:
            self.Alerta = []
        else:
            self.Alerta = Alerta
        if Erro is None:
            self.Erro = []
        else:
            self.Erro = Erro
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpListaRetornoLote)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpListaRetornoLote.subclass:
            return tpListaRetornoLote.subclass(*args_, **kwargs_)
        else:
            return tpListaRetornoLote(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.Alerta or
            self.Erro
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tpListaRetornoLote', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpListaRetornoLote')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='tpListaRetornoLote')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='tpListaRetornoLote', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='tpListaRetornoLote'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tpListaRetornoLote', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Alerta_ in self.Alerta:
            Alerta_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Alerta', pretty_print=pretty_print)
        for Erro_ in self.Erro:
            Erro_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Erro', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Alerta':
            obj_ = tpEvento.factory(parent_object_=self)
            obj_.build(child_)
            self.Alerta.append(obj_)
            obj_.original_tagname_ = 'Alerta'
        elif nodeName_ == 'Erro':
            obj_ = tpEvento.factory(parent_object_=self)
            obj_.build(child_)
            self.Erro.append(obj_)
            obj_.original_tagname_ = 'Erro'
# end class tpListaRetornoLote


class tpListaRetornoNFTS(GeneratedsSuper):
    """Lista de mensagens de retorno da NFTS"""
    subclass = None
    superclass = None
    def __init__(self, Alerta=None, Erro=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if Alerta is None:
            self.Alerta = []
        else:
            self.Alerta = Alerta
        if Erro is None:
            self.Erro = []
        else:
            self.Erro = Erro
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpListaRetornoNFTS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpListaRetornoNFTS.subclass:
            return tpListaRetornoNFTS.subclass(*args_, **kwargs_)
        else:
            return tpListaRetornoNFTS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.Alerta or
            self.Erro
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tpListaRetornoNFTS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpListaRetornoNFTS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='tpListaRetornoNFTS')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='tpListaRetornoNFTS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='tpListaRetornoNFTS'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tpListaRetornoNFTS', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Alerta_ in self.Alerta:
            Alerta_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Alerta', pretty_print=pretty_print)
        for Erro_ in self.Erro:
            Erro_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Erro', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Alerta':
            obj_ = tpEvento.factory(parent_object_=self)
            obj_.build(child_)
            self.Alerta.append(obj_)
            obj_.original_tagname_ = 'Alerta'
        elif nodeName_ == 'Erro':
            obj_ = tpEvento.factory(parent_object_=self)
            obj_.build(child_)
            self.Erro.append(obj_)
            obj_.original_tagname_ = 'Erro'
# end class tpListaRetornoNFTS


class tpListaRetornoConsultaNFTS(GeneratedsSuper):
    """Lista de mensagens de retorno do lote"""
    subclass = None
    superclass = None
    def __init__(self, ListaRetornoLote=None, NFTS=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if ListaRetornoLote is None:
            self.ListaRetornoLote = []
        else:
            self.ListaRetornoLote = ListaRetornoLote
        if NFTS is None:
            self.NFTS = []
        else:
            self.NFTS = NFTS
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpListaRetornoConsultaNFTS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpListaRetornoConsultaNFTS.subclass:
            return tpListaRetornoConsultaNFTS.subclass(*args_, **kwargs_)
        else:
            return tpListaRetornoConsultaNFTS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.ListaRetornoLote or
            self.NFTS
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tpListaRetornoConsultaNFTS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpListaRetornoConsultaNFTS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='tpListaRetornoConsultaNFTS')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='tpListaRetornoConsultaNFTS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='tpListaRetornoConsultaNFTS'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tpListaRetornoConsultaNFTS', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ListaRetornoLote_ in self.ListaRetornoLote:
            ListaRetornoLote_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ListaRetornoLote', pretty_print=pretty_print)
        for NFTS_ in self.NFTS:
            NFTS_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NFTS', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ListaRetornoLote':
            obj_ = tpListaRetornoLote.factory(parent_object_=self)
            obj_.build(child_)
            self.ListaRetornoLote.append(obj_)
            obj_.original_tagname_ = 'ListaRetornoLote'
        elif nodeName_ == 'NFTS':
            obj_ = tpNFTSRetorno.factory(parent_object_=self)
            obj_.build(child_)
            self.NFTS.append(obj_)
            obj_.original_tagname_ = 'NFTS'
# end class tpListaRetornoConsultaNFTS


class tpIdentificacaoDocumento(GeneratedsSuper):
    """Identificação da NFTS."""
    subclass = None
    superclass = None
    def __init__(self, Posicao=None, ChaveDocumento=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.Posicao = Posicao
        self.validate_PosicaoType(self.Posicao)
        self.ChaveDocumento = ChaveDocumento
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpIdentificacaoDocumento)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpIdentificacaoDocumento.subclass:
            return tpIdentificacaoDocumento.subclass(*args_, **kwargs_)
        else:
            return tpIdentificacaoDocumento(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_PosicaoType(self, value):
        # Validate type PosicaoType, a restriction on xs:int.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_PosicaoType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_PosicaoType_patterns_, ))
    validate_PosicaoType_patterns_ = [['^[0-9]{1,2}$']]
    def hasContent_(self):
        if (
            self.Posicao is not None or
            self.ChaveDocumento is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tpIdentificacaoDocumento', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpIdentificacaoDocumento')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='tpIdentificacaoDocumento')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='tpIdentificacaoDocumento', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='tpIdentificacaoDocumento'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tpIdentificacaoDocumento', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Posicao is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPosicao>%s</%sPosicao>%s' % (namespaceprefix_ , self.gds_format_integer(self.Posicao, input_name='Posicao'), namespaceprefix_ , eol_))
        if self.ChaveDocumento is not None:
            self.ChaveDocumento.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ChaveDocumento', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Posicao' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Posicao')
            self.Posicao = ival_
            # validate type PosicaoType
            self.validate_PosicaoType(self.Posicao)
        elif nodeName_ == 'ChaveDocumento':
            obj_ = tpChaveDocumento.factory(parent_object_=self)
            obj_.build(child_)
            self.ChaveDocumento = obj_
            obj_.original_tagname_ = 'ChaveDocumento'
# end class tpIdentificacaoDocumento


class tpIdentificacaoNFTS(GeneratedsSuper):
    """Identificação da NFTS."""
    subclass = None
    superclass = None
    def __init__(self, Posicao=None, ChaveNFTS=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.Posicao = Posicao
        self.validate_PosicaoType1(self.Posicao)
        self.ChaveNFTS = ChaveNFTS
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpIdentificacaoNFTS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpIdentificacaoNFTS.subclass:
            return tpIdentificacaoNFTS.subclass(*args_, **kwargs_)
        else:
            return tpIdentificacaoNFTS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_PosicaoType1(self, value):
        # Validate type PosicaoType1, a restriction on xs:int.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_PosicaoType1_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_PosicaoType1_patterns_, ))
    validate_PosicaoType1_patterns_ = [['^[0-9]{1,2}$']]
    def hasContent_(self):
        if (
            self.Posicao is not None or
            self.ChaveNFTS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tpIdentificacaoNFTS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpIdentificacaoNFTS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='tpIdentificacaoNFTS')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='tpIdentificacaoNFTS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='tpIdentificacaoNFTS'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tpIdentificacaoNFTS', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Posicao is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPosicao>%s</%sPosicao>%s' % (namespaceprefix_ , self.gds_format_integer(self.Posicao, input_name='Posicao'), namespaceprefix_ , eol_))
        if self.ChaveNFTS is not None:
            self.ChaveNFTS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ChaveNFTS', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Posicao' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Posicao')
            self.Posicao = ival_
            # validate type PosicaoType1
            self.validate_PosicaoType1(self.Posicao)
        elif nodeName_ == 'ChaveNFTS':
            obj_ = tpChaveNFTS.factory(parent_object_=self)
            obj_.build(child_)
            self.ChaveNFTS = obj_
            obj_.original_tagname_ = 'ChaveNFTS'
# end class tpIdentificacaoNFTS


class tpCPFCNPJ(GeneratedsSuper):
    """Tipo que representa um CPF/CNPJ."""
    subclass = None
    superclass = None
    def __init__(self, CPF=None, CNPJ=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.CPF = CPF
        self.validate_tpCPF(self.CPF)
        self.CNPJ = CNPJ
        self.validate_tpCNPJ(self.CNPJ)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpCPFCNPJ)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpCPFCNPJ.subclass:
            return tpCPFCNPJ.subclass(*args_, **kwargs_)
        else:
            return tpCPFCNPJ(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_tpCPF(self, value):
        # Validate type tpCPF, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_tpCPF_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpCPF_patterns_, ))
    validate_tpCPF_patterns_ = [['^[0-9]{11}$']]
    def validate_tpCNPJ(self, value):
        # Validate type tpCNPJ, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_tpCNPJ_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpCNPJ_patterns_, ))
    validate_tpCNPJ_patterns_ = [['^[0-9]{14}$']]
    def hasContent_(self):
        if (
            self.CPF is not None or
            self.CNPJ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tpCPFCNPJ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpCPFCNPJ')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='tpCPFCNPJ')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='tpCPFCNPJ', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='tpCPFCNPJ'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tpCPFCNPJ', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CPF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCPF>%s</%sCPF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CPF), input_name='CPF')), namespaceprefix_ , eol_))
        if self.CNPJ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCNPJ>%s</%sCNPJ>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CNPJ), input_name='CNPJ')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CPF':
            CPF_ = child_.text
            CPF_ = self.gds_validate_string(CPF_, node, 'CPF')
            self.CPF = CPF_
            # validate type tpCPF
            self.validate_tpCPF(self.CPF)
        elif nodeName_ == 'CNPJ':
            CNPJ_ = child_.text
            CNPJ_ = self.gds_validate_string(CNPJ_, node, 'CNPJ')
            self.CNPJ = CNPJ_
            # validate type tpCNPJ
            self.validate_tpCNPJ(self.CNPJ)
# end class tpCPFCNPJ


class tpRemetente(GeneratedsSuper):
    """Dados do Remetende CPF/CNPJ"""
    subclass = None
    superclass = None
    def __init__(self, CPFCNPJ=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.CPFCNPJ = CPFCNPJ
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpRemetente)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpRemetente.subclass:
            return tpRemetente.subclass(*args_, **kwargs_)
        else:
            return tpRemetente(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.CPFCNPJ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tpRemetente', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpRemetente')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='tpRemetente')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='tpRemetente', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='tpRemetente'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tpRemetente', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CPFCNPJ is not None:
            self.CPFCNPJ.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CPFCNPJ', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CPFCNPJ':
            obj_ = tpCPFCNPJ.factory(parent_object_=self)
            obj_.build(child_)
            self.CPFCNPJ = obj_
            obj_.original_tagname_ = 'CPFCNPJ'
# end class tpRemetente


class tpRemetente_ComCCM(GeneratedsSuper):
    """Dados do Remetende CPF/CNPJ e Inscricao Municipal"""
    subclass = None
    superclass = None
    def __init__(self, CPFCNPJ=None, InscricaoMunicipal=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.CPFCNPJ = CPFCNPJ
        self.InscricaoMunicipal = InscricaoMunicipal
        self.validate_tpInscricaoMunicipal(self.InscricaoMunicipal)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpRemetente_ComCCM)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpRemetente_ComCCM.subclass:
            return tpRemetente_ComCCM.subclass(*args_, **kwargs_)
        else:
            return tpRemetente_ComCCM(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_tpInscricaoMunicipal(self, value):
        # Validate type tpInscricaoMunicipal, a restriction on xs:long.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_tpInscricaoMunicipal_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpInscricaoMunicipal_patterns_, ))
    validate_tpInscricaoMunicipal_patterns_ = [['^[0-9]{8,8}$']]
    def hasContent_(self):
        if (
            self.CPFCNPJ is not None or
            self.InscricaoMunicipal is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tpRemetente_ComCCM', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpRemetente_ComCCM')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='tpRemetente_ComCCM')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='tpRemetente_ComCCM', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='tpRemetente_ComCCM'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tpRemetente_ComCCM', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CPFCNPJ is not None:
            self.CPFCNPJ.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CPFCNPJ', pretty_print=pretty_print)
        if self.InscricaoMunicipal is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sInscricaoMunicipal>%s</%sInscricaoMunicipal>%s' % (namespaceprefix_ , self.gds_format_integer(self.InscricaoMunicipal, input_name='InscricaoMunicipal'), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CPFCNPJ':
            obj_ = tpCPFCNPJ.factory(parent_object_=self)
            obj_.build(child_)
            self.CPFCNPJ = obj_
            obj_.original_tagname_ = 'CPFCNPJ'
        elif nodeName_ == 'InscricaoMunicipal' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'InscricaoMunicipal')
            self.InscricaoMunicipal = ival_
            # validate type tpInscricaoMunicipal
            self.validate_tpInscricaoMunicipal(self.InscricaoMunicipal)
# end class tpRemetente_ComCCM


class tpChaveDocumento(GeneratedsSuper):
    """Chave de identificação da NFTS."""
    subclass = None
    superclass = None
    def __init__(self, InscricaoMunicipal=None, SerieNFTS=None, NumeroDocumento=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.InscricaoMunicipal = InscricaoMunicipal
        self.validate_tpInscricaoMunicipal(self.InscricaoMunicipal)
        self.SerieNFTS = SerieNFTS
        self.validate_tpSerieNFTS(self.SerieNFTS)
        self.NumeroDocumento = NumeroDocumento
        self.validate_tpNumeroDocumento(self.NumeroDocumento)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpChaveDocumento)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpChaveDocumento.subclass:
            return tpChaveDocumento.subclass(*args_, **kwargs_)
        else:
            return tpChaveDocumento(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_tpInscricaoMunicipal(self, value):
        # Validate type tpInscricaoMunicipal, a restriction on xs:long.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_tpInscricaoMunicipal_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpInscricaoMunicipal_patterns_, ))
    validate_tpInscricaoMunicipal_patterns_ = [['^[0-9]{8,8}$']]
    def validate_tpSerieNFTS(self, value):
        # Validate type tpSerieNFTS, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 5:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpSerieNFTS' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tpSerieNFTS' % {"value" : value.encode("utf-8")} )
    def validate_tpNumeroDocumento(self, value):
        # Validate type tpNumeroDocumento, a restriction on xs:nonNegativeInteger.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 12:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on tpNumeroDocumento' % {"value" : value} )
    def hasContent_(self):
        if (
            self.InscricaoMunicipal is not None or
            self.SerieNFTS is not None or
            self.NumeroDocumento is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tpChaveDocumento', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpChaveDocumento')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='tpChaveDocumento')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='tpChaveDocumento', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='tpChaveDocumento'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tpChaveDocumento', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.InscricaoMunicipal is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sInscricaoMunicipal>%s</%sInscricaoMunicipal>%s' % (namespaceprefix_ , self.gds_format_integer(self.InscricaoMunicipal, input_name='InscricaoMunicipal'), namespaceprefix_ , eol_))
        if self.SerieNFTS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSerieNFTS>%s</%sSerieNFTS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SerieNFTS), input_name='SerieNFTS')), namespaceprefix_ , eol_))
        if self.NumeroDocumento is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNumeroDocumento>%s</%sNumeroDocumento>%s' % (namespaceprefix_ , self.gds_format_integer(self.NumeroDocumento, input_name='NumeroDocumento'), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'InscricaoMunicipal' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'InscricaoMunicipal')
            self.InscricaoMunicipal = ival_
            # validate type tpInscricaoMunicipal
            self.validate_tpInscricaoMunicipal(self.InscricaoMunicipal)
        elif nodeName_ == 'SerieNFTS':
            SerieNFTS_ = child_.text
            SerieNFTS_ = self.gds_validate_string(SerieNFTS_, node, 'SerieNFTS')
            self.SerieNFTS = SerieNFTS_
            # validate type tpSerieNFTS
            self.validate_tpSerieNFTS(self.SerieNFTS)
        elif nodeName_ == 'NumeroDocumento' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'NumeroDocumento')
            self.NumeroDocumento = ival_
            # validate type tpNumeroDocumento
            self.validate_tpNumeroDocumento(self.NumeroDocumento)
# end class tpChaveDocumento


class tpChaveNFTS(GeneratedsSuper):
    """Chave de identificação da NFTS."""
    subclass = None
    superclass = None
    def __init__(self, InscricaoMunicipal=None, NumeroNFTS=None, CodigoVerificacao=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.InscricaoMunicipal = InscricaoMunicipal
        self.validate_tpInscricaoMunicipal(self.InscricaoMunicipal)
        self.NumeroNFTS = NumeroNFTS
        self.validate_tpNumeroNFTS(self.NumeroNFTS)
        self.CodigoVerificacao = CodigoVerificacao
        self.validate_tpCodigoVerificacao(self.CodigoVerificacao)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpChaveNFTS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpChaveNFTS.subclass:
            return tpChaveNFTS.subclass(*args_, **kwargs_)
        else:
            return tpChaveNFTS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_tpInscricaoMunicipal(self, value):
        # Validate type tpInscricaoMunicipal, a restriction on xs:long.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_tpInscricaoMunicipal_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpInscricaoMunicipal_patterns_, ))
    validate_tpInscricaoMunicipal_patterns_ = [['^[0-9]{8,8}$']]
    def validate_tpNumeroNFTS(self, value):
        # Validate type tpNumeroNFTS, a restriction on xs:nonNegativeInteger.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 12:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on tpNumeroNFTS' % {"value" : value} )
    def validate_tpCodigoVerificacao(self, value):
        # Validate type tpCodigoVerificacao, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 8:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpCodigoVerificacao' % {"value" : value.encode("utf-8")} )
            if len(value) < 8:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tpCodigoVerificacao' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.InscricaoMunicipal is not None or
            self.NumeroNFTS is not None or
            self.CodigoVerificacao is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tpChaveNFTS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpChaveNFTS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='tpChaveNFTS')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='tpChaveNFTS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='tpChaveNFTS'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tpChaveNFTS', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.InscricaoMunicipal is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sInscricaoMunicipal>%s</%sInscricaoMunicipal>%s' % (namespaceprefix_ , self.gds_format_integer(self.InscricaoMunicipal, input_name='InscricaoMunicipal'), namespaceprefix_ , eol_))
        if self.NumeroNFTS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNumeroNFTS>%s</%sNumeroNFTS>%s' % (namespaceprefix_ , self.gds_format_integer(self.NumeroNFTS, input_name='NumeroNFTS'), namespaceprefix_ , eol_))
        if self.CodigoVerificacao is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCodigoVerificacao>%s</%sCodigoVerificacao>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CodigoVerificacao), input_name='CodigoVerificacao')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'InscricaoMunicipal' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'InscricaoMunicipal')
            self.InscricaoMunicipal = ival_
            # validate type tpInscricaoMunicipal
            self.validate_tpInscricaoMunicipal(self.InscricaoMunicipal)
        elif nodeName_ == 'NumeroNFTS' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'NumeroNFTS')
            self.NumeroNFTS = ival_
            # validate type tpNumeroNFTS
            self.validate_tpNumeroNFTS(self.NumeroNFTS)
        elif nodeName_ == 'CodigoVerificacao':
            CodigoVerificacao_ = child_.text
            CodigoVerificacao_ = self.gds_validate_string(CodigoVerificacao_, node, 'CodigoVerificacao')
            self.CodigoVerificacao = CodigoVerificacao_
            # validate type tpCodigoVerificacao
            self.validate_tpCodigoVerificacao(self.CodigoVerificacao)
# end class tpChaveNFTS


class tpEndereco(GeneratedsSuper):
    """Tipo Endereço."""
    subclass = None
    superclass = None
    def __init__(self, TipoLogradouro=None, Logradouro=None, NumeroEndereco=None, ComplementoEndereco=None, Bairro=None, Cidade=None, UF=None, CEP=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.TipoLogradouro = TipoLogradouro
        self.validate_tpTipoLogradouro(self.TipoLogradouro)
        self.Logradouro = Logradouro
        self.validate_tpLogradouro(self.Logradouro)
        self.NumeroEndereco = NumeroEndereco
        self.validate_tpNumeroEndereco(self.NumeroEndereco)
        self.ComplementoEndereco = ComplementoEndereco
        self.validate_tpComplementoEndereco(self.ComplementoEndereco)
        self.Bairro = Bairro
        self.validate_tpBairro(self.Bairro)
        self.Cidade = Cidade
        self.validate_tpCidadeTexto(self.Cidade)
        self.UF = UF
        self.validate_tpUF(self.UF)
        self.CEP = CEP
        self.validate_tpCEP(self.CEP)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpEndereco)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpEndereco.subclass:
            return tpEndereco.subclass(*args_, **kwargs_)
        else:
            return tpEndereco(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_tpTipoLogradouro(self, value):
        # Validate type tpTipoLogradouro, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 3:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpTipoLogradouro' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tpTipoLogradouro' % {"value" : value.encode("utf-8")} )
    def validate_tpLogradouro(self, value):
        # Validate type tpLogradouro, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 50:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpLogradouro' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tpLogradouro' % {"value" : value.encode("utf-8")} )
    def validate_tpNumeroEndereco(self, value):
        # Validate type tpNumeroEndereco, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 10:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpNumeroEndereco' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tpNumeroEndereco' % {"value" : value.encode("utf-8")} )
    def validate_tpComplementoEndereco(self, value):
        # Validate type tpComplementoEndereco, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 30:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpComplementoEndereco' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tpComplementoEndereco' % {"value" : value.encode("utf-8")} )
    def validate_tpBairro(self, value):
        # Validate type tpBairro, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 30:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpBairro' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tpBairro' % {"value" : value.encode("utf-8")} )
    def validate_tpCidadeTexto(self, value):
        # Validate type tpCidadeTexto, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 50:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpCidadeTexto' % {"value" : value.encode("utf-8")} )
            if len(value) < 3:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tpCidadeTexto' % {"value" : value.encode("utf-8")} )
    def validate_tpUF(self, value):
        # Validate type tpUF, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 2:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpUF' % {"value" : value.encode("utf-8")} )
            if len(value) < 2:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tpUF' % {"value" : value.encode("utf-8")} )
    def validate_tpCEP(self, value):
        # Validate type tpCEP, a restriction on xs:int.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_tpCEP_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpCEP_patterns_, ))
    validate_tpCEP_patterns_ = [['^[0-9]{7,8}$']]
    def hasContent_(self):
        if (
            self.TipoLogradouro is not None or
            self.Logradouro is not None or
            self.NumeroEndereco is not None or
            self.ComplementoEndereco is not None or
            self.Bairro is not None or
            self.Cidade is not None or
            self.UF is not None or
            self.CEP is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tpEndereco', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpEndereco')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='tpEndereco')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='tpEndereco', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='tpEndereco'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tpEndereco', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TipoLogradouro is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTipoLogradouro>%s</%sTipoLogradouro>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TipoLogradouro), input_name='TipoLogradouro')), namespaceprefix_ , eol_))
        if self.Logradouro is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLogradouro>%s</%sLogradouro>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Logradouro), input_name='Logradouro')), namespaceprefix_ , eol_))
        if self.NumeroEndereco is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNumeroEndereco>%s</%sNumeroEndereco>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NumeroEndereco), input_name='NumeroEndereco')), namespaceprefix_ , eol_))
        if self.ComplementoEndereco is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sComplementoEndereco>%s</%sComplementoEndereco>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ComplementoEndereco), input_name='ComplementoEndereco')), namespaceprefix_ , eol_))
        if self.Bairro is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBairro>%s</%sBairro>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Bairro), input_name='Bairro')), namespaceprefix_ , eol_))
        if self.Cidade is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCidade>%s</%sCidade>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Cidade), input_name='Cidade')), namespaceprefix_ , eol_))
        if self.UF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUF>%s</%sUF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.UF), input_name='UF')), namespaceprefix_ , eol_))
        if self.CEP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCEP>%s</%sCEP>%s' % (namespaceprefix_ , self.gds_format_integer(self.CEP, input_name='CEP'), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TipoLogradouro':
            TipoLogradouro_ = child_.text
            TipoLogradouro_ = self.gds_validate_string(TipoLogradouro_, node, 'TipoLogradouro')
            self.TipoLogradouro = TipoLogradouro_
            # validate type tpTipoLogradouro
            self.validate_tpTipoLogradouro(self.TipoLogradouro)
        elif nodeName_ == 'Logradouro':
            Logradouro_ = child_.text
            Logradouro_ = self.gds_validate_string(Logradouro_, node, 'Logradouro')
            self.Logradouro = Logradouro_
            # validate type tpLogradouro
            self.validate_tpLogradouro(self.Logradouro)
        elif nodeName_ == 'NumeroEndereco':
            NumeroEndereco_ = child_.text
            NumeroEndereco_ = self.gds_validate_string(NumeroEndereco_, node, 'NumeroEndereco')
            self.NumeroEndereco = NumeroEndereco_
            # validate type tpNumeroEndereco
            self.validate_tpNumeroEndereco(self.NumeroEndereco)
        elif nodeName_ == 'ComplementoEndereco':
            ComplementoEndereco_ = child_.text
            ComplementoEndereco_ = self.gds_validate_string(ComplementoEndereco_, node, 'ComplementoEndereco')
            self.ComplementoEndereco = ComplementoEndereco_
            # validate type tpComplementoEndereco
            self.validate_tpComplementoEndereco(self.ComplementoEndereco)
        elif nodeName_ == 'Bairro':
            Bairro_ = child_.text
            Bairro_ = self.gds_validate_string(Bairro_, node, 'Bairro')
            self.Bairro = Bairro_
            # validate type tpBairro
            self.validate_tpBairro(self.Bairro)
        elif nodeName_ == 'Cidade':
            Cidade_ = child_.text
            Cidade_ = self.gds_validate_string(Cidade_, node, 'Cidade')
            self.Cidade = Cidade_
            # validate type tpCidadeTexto
            self.validate_tpCidadeTexto(self.Cidade)
        elif nodeName_ == 'UF':
            UF_ = child_.text
            UF_ = self.gds_validate_string(UF_, node, 'UF')
            self.UF = UF_
            # validate type tpUF
            self.validate_tpUF(self.UF)
        elif nodeName_ == 'CEP' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'CEP')
            self.CEP = ival_
            # validate type tpCEP
            self.validate_tpCEP(self.CEP)
# end class tpEndereco


class tpPrestador(GeneratedsSuper):
    """Dados do Prestador de serviço"""
    subclass = None
    superclass = None
    def __init__(self, CPFCNPJ=None, InscricaoMunicipal=None, RazaoSocialPrestador=None, Endereco=None, Email=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.CPFCNPJ = CPFCNPJ
        self.InscricaoMunicipal = InscricaoMunicipal
        self.validate_tpInscricaoMunicipal(self.InscricaoMunicipal)
        self.RazaoSocialPrestador = RazaoSocialPrestador
        self.validate_tpRazaoSocial(self.RazaoSocialPrestador)
        self.Endereco = Endereco
        self.Email = Email
        self.validate_tpEmail(self.Email)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpPrestador)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpPrestador.subclass:
            return tpPrestador.subclass(*args_, **kwargs_)
        else:
            return tpPrestador(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_tpInscricaoMunicipal(self, value):
        # Validate type tpInscricaoMunicipal, a restriction on xs:long.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_tpInscricaoMunicipal_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpInscricaoMunicipal_patterns_, ))
    validate_tpInscricaoMunicipal_patterns_ = [['^[0-9]{8,8}$']]
    def validate_tpRazaoSocial(self, value):
        # Validate type tpRazaoSocial, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 75:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpRazaoSocial' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tpRazaoSocial' % {"value" : value.encode("utf-8")} )
    def validate_tpEmail(self, value):
        # Validate type tpEmail, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 75:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpEmail' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tpEmail' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_tpEmail_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpEmail_patterns_, ))
    validate_tpEmail_patterns_ = [["^^[A-Za-z0-9_]+([-+.'][A-Za-z0-9_]+)*@[A-Za-z0-9_]+([-.][A-Za-z0-9_]+)*\\.[A-Za-z0-9_]+([-.][A-Za-z0-9_]+)*$$"]]
    def hasContent_(self):
        if (
            self.CPFCNPJ is not None or
            self.InscricaoMunicipal is not None or
            self.RazaoSocialPrestador is not None or
            self.Endereco is not None or
            self.Email is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tpPrestador', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpPrestador')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='tpPrestador')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='tpPrestador', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='tpPrestador'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tpPrestador', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CPFCNPJ is not None:
            self.CPFCNPJ.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CPFCNPJ', pretty_print=pretty_print)
        if self.InscricaoMunicipal is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sInscricaoMunicipal>%s</%sInscricaoMunicipal>%s' % (namespaceprefix_ , self.gds_format_integer(self.InscricaoMunicipal, input_name='InscricaoMunicipal'), namespaceprefix_ , eol_))
        if self.RazaoSocialPrestador is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRazaoSocialPrestador>%s</%sRazaoSocialPrestador>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.RazaoSocialPrestador), input_name='RazaoSocialPrestador')), namespaceprefix_ , eol_))
        if self.Endereco is not None:
            self.Endereco.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Endereco', pretty_print=pretty_print)
        if self.Email is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEmail>%s</%sEmail>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Email), input_name='Email')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CPFCNPJ':
            obj_ = tpCPFCNPJ.factory(parent_object_=self)
            obj_.build(child_)
            self.CPFCNPJ = obj_
            obj_.original_tagname_ = 'CPFCNPJ'
        elif nodeName_ == 'InscricaoMunicipal' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'InscricaoMunicipal')
            self.InscricaoMunicipal = ival_
            # validate type tpInscricaoMunicipal
            self.validate_tpInscricaoMunicipal(self.InscricaoMunicipal)
        elif nodeName_ == 'RazaoSocialPrestador':
            RazaoSocialPrestador_ = child_.text
            RazaoSocialPrestador_ = self.gds_validate_string(RazaoSocialPrestador_, node, 'RazaoSocialPrestador')
            self.RazaoSocialPrestador = RazaoSocialPrestador_
            # validate type tpRazaoSocial
            self.validate_tpRazaoSocial(self.RazaoSocialPrestador)
        elif nodeName_ == 'Endereco':
            obj_ = tpEndereco.factory(parent_object_=self)
            obj_.build(child_)
            self.Endereco = obj_
            obj_.original_tagname_ = 'Endereco'
        elif nodeName_ == 'Email':
            Email_ = child_.text
            Email_ = self.gds_validate_string(Email_, node, 'Email')
            self.Email = Email_
            # validate type tpEmail
            self.validate_tpEmail(self.Email)
# end class tpPrestador


class tpTomador(GeneratedsSuper):
    """Dados do tomador de serviço"""
    subclass = None
    superclass = None
    def __init__(self, CPFCNPJ=None, RazaoSocial=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.CPFCNPJ = CPFCNPJ
        self.RazaoSocial = RazaoSocial
        self.validate_tpRazaoSocial(self.RazaoSocial)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpTomador)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpTomador.subclass:
            return tpTomador.subclass(*args_, **kwargs_)
        else:
            return tpTomador(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_tpRazaoSocial(self, value):
        # Validate type tpRazaoSocial, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 75:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpRazaoSocial' % {"value" : value.encode("utf-8")} )
            if len(value) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tpRazaoSocial' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.CPFCNPJ is not None or
            self.RazaoSocial is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tpTomador', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpTomador')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='tpTomador')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='tpTomador', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='tpTomador'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tpTomador', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CPFCNPJ is not None:
            self.CPFCNPJ.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CPFCNPJ', pretty_print=pretty_print)
        if self.RazaoSocial is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRazaoSocial>%s</%sRazaoSocial>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.RazaoSocial), input_name='RazaoSocial')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CPFCNPJ':
            obj_ = tpCPFCNPJ.factory(parent_object_=self)
            obj_.build(child_)
            self.CPFCNPJ = obj_
            obj_.original_tagname_ = 'CPFCNPJ'
        elif nodeName_ == 'RazaoSocial':
            RazaoSocial_ = child_.text
            RazaoSocial_ = self.gds_validate_string(RazaoSocial_, node, 'RazaoSocial')
            self.RazaoSocial = RazaoSocial_
            # validate type tpRazaoSocial
            self.validate_tpRazaoSocial(self.RazaoSocial)
# end class tpTomador


class tpNFTS(GeneratedsSuper):
    """Tipo que representa uma NFTS."""
    subclass = None
    superclass = None
    def __init__(self, TipoDocumento=None, ChaveDocumento=None, DataPrestacao=None, StatusNFTS=None, TributacaoNFTS=None, ValorServicos=None, ValorDeducoes=None, CodigoServico=None, CodigoSubItem=None, AliquotaServicos=None, ISSRetidoTomador=None, ISSRetidoIntermediario=None, DescumpreLeiComplementar1572016=None, Prestador=None, RegimeTributacao=None, DataPagamento=None, Discriminacao=None, TipoNFTS=None, Tomador=None, Assinatura=None, CodigoCEI=None, MatriculaObra=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.TipoDocumento = TipoDocumento
        self.validate_tpTipoDocumentoNFTS(self.TipoDocumento)
        self.ChaveDocumento = ChaveDocumento
        if isinstance(DataPrestacao, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(DataPrestacao, '%Y-%m-%d').date()
        else:
            initvalue_ = DataPrestacao
        self.DataPrestacao = initvalue_
        self.StatusNFTS = StatusNFTS
        self.validate_tpStatusNFTS(self.StatusNFTS)
        self.TributacaoNFTS = TributacaoNFTS
        self.validate_tpTributacaoNFTS(self.TributacaoNFTS)
        self.ValorServicos = ValorServicos
        self.validate_tpValor(self.ValorServicos)
        self.ValorDeducoes = ValorDeducoes
        self.validate_tpValor(self.ValorDeducoes)
        self.CodigoServico = CodigoServico
        self.validate_tpCodigoServico(self.CodigoServico)
        self.CodigoSubItem = CodigoSubItem
        self.validate_tpCodigoSubitem(self.CodigoSubItem)
        self.AliquotaServicos = AliquotaServicos
        self.validate_tpAliquota(self.AliquotaServicos)
        self.ISSRetidoTomador = ISSRetidoTomador
        self.validate_tpISSRetidoTomador(self.ISSRetidoTomador)
        self.ISSRetidoIntermediario = ISSRetidoIntermediario
        self.validate_tpISSRetidoIntermediario(self.ISSRetidoIntermediario)
        self.DescumpreLeiComplementar1572016 = DescumpreLeiComplementar1572016
        self.validate_tpDescumpreLeiComplementar1572016(self.DescumpreLeiComplementar1572016)
        self.Prestador = Prestador
        self.RegimeTributacao = RegimeTributacao
        self.validate_tpRegimeTributacao(self.RegimeTributacao)
        if isinstance(DataPagamento, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(DataPagamento, '%Y-%m-%d').date()
        else:
            initvalue_ = DataPagamento
        self.DataPagamento = initvalue_
        self.Discriminacao = Discriminacao
        self.validate_tpDiscriminacao(self.Discriminacao)
        self.TipoNFTS = TipoNFTS
        self.validate_tpTipoNFTS(self.TipoNFTS)
        self.Tomador = Tomador
        self.Assinatura = Assinatura
        self.validate_tpAssinatura(self.Assinatura)
        self.CodigoCEI = CodigoCEI
        self.validate_tpNumeroNFTS(self.CodigoCEI)
        self.MatriculaObra = MatriculaObra
        self.validate_tpNumeroNFTS(self.MatriculaObra)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpNFTS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpNFTS.subclass:
            return tpNFTS.subclass(*args_, **kwargs_)
        else:
            return tpNFTS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_tpTipoDocumentoNFTS(self, value):
        # Validate type tpTipoDocumentoNFTS, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['01', '02', '03', '05']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tpTipoDocumentoNFTS' % {"value" : value.encode("utf-8")} )
            if len(value) > 2:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpTipoDocumentoNFTS' % {"value" : value.encode("utf-8")} )
            if len(value) < 2:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tpTipoDocumentoNFTS' % {"value" : value.encode("utf-8")} )
    def validate_tpStatusNFTS(self, value):
        # Validate type tpStatusNFTS, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['N', 'C']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tpStatusNFTS' % {"value" : value.encode("utf-8")} )
    def validate_tpTributacaoNFTS(self, value):
        # Validate type tpTributacaoNFTS, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['T', 'I', 'J']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tpTributacaoNFTS' % {"value" : value.encode("utf-8")} )
    def validate_tpValor(self, value):
        # Validate type tpValor, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on tpValor' % {"value" : value} )
            if len(str(value)) >= 15:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on tpValor' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_tpValor_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpValor_patterns_, ))
    validate_tpValor_patterns_ = [['^0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{0,2})?$']]
    def validate_tpCodigoServico(self, value):
        # Validate type tpCodigoServico, a restriction on xs:int.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_tpCodigoServico_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpCodigoServico_patterns_, ))
    validate_tpCodigoServico_patterns_ = [['^[0-9]{4,5}$']]
    def validate_tpCodigoSubitem(self, value):
        # Validate type tpCodigoSubitem, a restriction on xs:short.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_tpCodigoSubitem_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpCodigoSubitem_patterns_, ))
    validate_tpCodigoSubitem_patterns_ = [['^[0-9]{3,4}$']]
    def validate_tpAliquota(self, value):
        # Validate type tpAliquota, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on tpAliquota' % {"value" : value} )
            if len(str(value)) >= 5:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on tpAliquota' % {"value" : value} )
    def validate_tpISSRetidoTomador(self, value):
        # Validate type tpISSRetidoTomador, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_tpISSRetidoIntermediario(self, value):
        # Validate type tpISSRetidoIntermediario, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_tpDescumpreLeiComplementar1572016(self, value):
        # Validate type tpDescumpreLeiComplementar1572016, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_tpRegimeTributacao(self, value):
        # Validate type tpRegimeTributacao, a restriction on xs:short.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_tpRegimeTributacao_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpRegimeTributacao_patterns_, ))
    validate_tpRegimeTributacao_patterns_ = [['^0|4|5$']]
    def validate_tpDiscriminacao(self, value):
        # Validate type tpDiscriminacao, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 2000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpDiscriminacao' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tpDiscriminacao' % {"value" : value.encode("utf-8")} )
    def validate_tpTipoNFTS(self, value):
        # Validate type tpTipoNFTS, a restriction on xs:short.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_tpTipoNFTS_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpTipoNFTS_patterns_, ))
    validate_tpTipoNFTS_patterns_ = [['^1|2$']]
    def validate_tpAssinatura(self, value):
        # Validate type tpAssinatura, a restriction on xs:base64Binary.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_tpNumeroNFTS(self, value):
        # Validate type tpNumeroNFTS, a restriction on xs:nonNegativeInteger.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) >= 12:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on tpNumeroNFTS' % {"value" : value} )
    def hasContent_(self):
        if (
            self.TipoDocumento is not None or
            self.ChaveDocumento is not None or
            self.DataPrestacao is not None or
            self.StatusNFTS is not None or
            self.TributacaoNFTS is not None or
            self.ValorServicos is not None or
            self.ValorDeducoes is not None or
            self.CodigoServico is not None or
            self.CodigoSubItem is not None or
            self.AliquotaServicos is not None or
            self.ISSRetidoTomador is not None or
            self.ISSRetidoIntermediario is not None or
            self.DescumpreLeiComplementar1572016 is not None or
            self.Prestador is not None or
            self.RegimeTributacao is not None or
            self.DataPagamento is not None or
            self.Discriminacao is not None or
            self.TipoNFTS is not None or
            self.Tomador is not None or
            self.Assinatura is not None or
            self.CodigoCEI is not None or
            self.MatriculaObra is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tpNFTS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpNFTS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='tpNFTS')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='tpNFTS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='tpNFTS'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tpNFTS', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TipoDocumento is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTipoDocumento>%s</%sTipoDocumento>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TipoDocumento), input_name='TipoDocumento')), namespaceprefix_ , eol_))
        if self.ChaveDocumento is not None:
            self.ChaveDocumento.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ChaveDocumento', pretty_print=pretty_print)
        if self.DataPrestacao is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDataPrestacao>%s</%sDataPrestacao>%s' % (namespaceprefix_ , self.gds_format_date(self.DataPrestacao, input_name='DataPrestacao'), namespaceprefix_ , eol_))
        if self.StatusNFTS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStatusNFTS>%s</%sStatusNFTS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.StatusNFTS), input_name='StatusNFTS')), namespaceprefix_ , eol_))
        if self.TributacaoNFTS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTributacaoNFTS>%s</%sTributacaoNFTS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TributacaoNFTS), input_name='TributacaoNFTS')), namespaceprefix_ , eol_))
        if self.ValorServicos is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sValorServicos>%s</%sValorServicos>%s' % (namespaceprefix_ , self.gds_format_float(self.ValorServicos, input_name='ValorServicos'), namespaceprefix_ , eol_))
        if self.ValorDeducoes is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sValorDeducoes>%s</%sValorDeducoes>%s' % (namespaceprefix_ , self.gds_format_float(self.ValorDeducoes, input_name='ValorDeducoes'), namespaceprefix_ , eol_))
        if self.CodigoServico is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCodigoServico>%s</%sCodigoServico>%s' % (namespaceprefix_ , self.gds_format_integer(self.CodigoServico, input_name='CodigoServico'), namespaceprefix_ , eol_))
        if self.CodigoSubItem is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCodigoSubItem>%s</%sCodigoSubItem>%s' % (namespaceprefix_ , self.gds_format_integer(self.CodigoSubItem, input_name='CodigoSubItem'), namespaceprefix_ , eol_))
        if self.AliquotaServicos is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAliquotaServicos>%s</%sAliquotaServicos>%s' % (namespaceprefix_ , self.gds_format_float(self.AliquotaServicos, input_name='AliquotaServicos'), namespaceprefix_ , eol_))
        if self.ISSRetidoTomador is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sISSRetidoTomador>%s</%sISSRetidoTomador>%s' % (namespaceprefix_ , self.gds_format_boolean(self.ISSRetidoTomador, input_name='ISSRetidoTomador'), namespaceprefix_ , eol_))
        if self.ISSRetidoIntermediario is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sISSRetidoIntermediario>%s</%sISSRetidoIntermediario>%s' % (namespaceprefix_ , self.gds_format_boolean(self.ISSRetidoIntermediario, input_name='ISSRetidoIntermediario'), namespaceprefix_ , eol_))
        if self.DescumpreLeiComplementar1572016 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDescumpreLeiComplementar1572016>%s</%sDescumpreLeiComplementar1572016>%s' % (namespaceprefix_ , self.gds_format_boolean(self.DescumpreLeiComplementar1572016, input_name='DescumpreLeiComplementar1572016'), namespaceprefix_ , eol_))
        if self.Prestador is not None:
            self.Prestador.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Prestador', pretty_print=pretty_print)
        if self.RegimeTributacao is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRegimeTributacao>%s</%sRegimeTributacao>%s' % (namespaceprefix_ , self.gds_format_integer(self.RegimeTributacao, input_name='RegimeTributacao'), namespaceprefix_ , eol_))
        if self.DataPagamento is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDataPagamento>%s</%sDataPagamento>%s' % (namespaceprefix_ , self.gds_format_date(self.DataPagamento, input_name='DataPagamento'), namespaceprefix_ , eol_))
        if self.Discriminacao is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDiscriminacao>%s</%sDiscriminacao>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Discriminacao), input_name='Discriminacao')), namespaceprefix_ , eol_))
        if self.TipoNFTS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTipoNFTS>%s</%sTipoNFTS>%s' % (namespaceprefix_ , self.gds_format_integer(self.TipoNFTS, input_name='TipoNFTS'), namespaceprefix_ , eol_))
        if self.Tomador is not None:
            self.Tomador.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Tomador', pretty_print=pretty_print)
        if self.Assinatura is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAssinatura>%s</%sAssinatura>%s' % (namespaceprefix_ , self.gds_format_base64(self.Assinatura, input_name='Assinatura'), namespaceprefix_ , eol_))
        if self.CodigoCEI is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCodigoCEI>%s</%sCodigoCEI>%s' % (namespaceprefix_ , self.gds_format_integer(self.CodigoCEI, input_name='CodigoCEI'), namespaceprefix_ , eol_))
        if self.MatriculaObra is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMatriculaObra>%s</%sMatriculaObra>%s' % (namespaceprefix_ , self.gds_format_integer(self.MatriculaObra, input_name='MatriculaObra'), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TipoDocumento':
            TipoDocumento_ = child_.text
            TipoDocumento_ = self.gds_validate_string(TipoDocumento_, node, 'TipoDocumento')
            self.TipoDocumento = TipoDocumento_
            # validate type tpTipoDocumentoNFTS
            self.validate_tpTipoDocumentoNFTS(self.TipoDocumento)
        elif nodeName_ == 'ChaveDocumento':
            obj_ = tpChaveDocumento.factory(parent_object_=self)
            obj_.build(child_)
            self.ChaveDocumento = obj_
            obj_.original_tagname_ = 'ChaveDocumento'
        elif nodeName_ == 'DataPrestacao':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.DataPrestacao = dval_
        elif nodeName_ == 'StatusNFTS':
            StatusNFTS_ = child_.text
            StatusNFTS_ = self.gds_validate_string(StatusNFTS_, node, 'StatusNFTS')
            self.StatusNFTS = StatusNFTS_
            # validate type tpStatusNFTS
            self.validate_tpStatusNFTS(self.StatusNFTS)
        elif nodeName_ == 'TributacaoNFTS':
            TributacaoNFTS_ = child_.text
            TributacaoNFTS_ = self.gds_validate_string(TributacaoNFTS_, node, 'TributacaoNFTS')
            self.TributacaoNFTS = TributacaoNFTS_
            # validate type tpTributacaoNFTS
            self.validate_tpTributacaoNFTS(self.TributacaoNFTS)
        elif nodeName_ == 'ValorServicos' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'ValorServicos')
            self.ValorServicos = fval_
            # validate type tpValor
            self.validate_tpValor(self.ValorServicos)
        elif nodeName_ == 'ValorDeducoes' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'ValorDeducoes')
            self.ValorDeducoes = fval_
            # validate type tpValor
            self.validate_tpValor(self.ValorDeducoes)
        elif nodeName_ == 'CodigoServico' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'CodigoServico')
            self.CodigoServico = ival_
            # validate type tpCodigoServico
            self.validate_tpCodigoServico(self.CodigoServico)
        elif nodeName_ == 'CodigoSubItem' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'CodigoSubItem')
            self.CodigoSubItem = ival_
            # validate type tpCodigoSubitem
            self.validate_tpCodigoSubitem(self.CodigoSubItem)
        elif nodeName_ == 'AliquotaServicos' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AliquotaServicos')
            self.AliquotaServicos = fval_
            # validate type tpAliquota
            self.validate_tpAliquota(self.AliquotaServicos)
        elif nodeName_ == 'ISSRetidoTomador':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'ISSRetidoTomador')
            self.ISSRetidoTomador = ival_
            # validate type tpISSRetidoTomador
            self.validate_tpISSRetidoTomador(self.ISSRetidoTomador)
        elif nodeName_ == 'ISSRetidoIntermediario':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'ISSRetidoIntermediario')
            self.ISSRetidoIntermediario = ival_
            # validate type tpISSRetidoIntermediario
            self.validate_tpISSRetidoIntermediario(self.ISSRetidoIntermediario)
        elif nodeName_ == 'DescumpreLeiComplementar1572016':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'DescumpreLeiComplementar1572016')
            self.DescumpreLeiComplementar1572016 = ival_
            # validate type tpDescumpreLeiComplementar1572016
            self.validate_tpDescumpreLeiComplementar1572016(self.DescumpreLeiComplementar1572016)
        elif nodeName_ == 'Prestador':
            obj_ = tpPrestador.factory(parent_object_=self)
            obj_.build(child_)
            self.Prestador = obj_
            obj_.original_tagname_ = 'Prestador'
        elif nodeName_ == 'RegimeTributacao' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'RegimeTributacao')
            self.RegimeTributacao = ival_
            # validate type tpRegimeTributacao
            self.validate_tpRegimeTributacao(self.RegimeTributacao)
        elif nodeName_ == 'DataPagamento':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.DataPagamento = dval_
        elif nodeName_ == 'Discriminacao':
            Discriminacao_ = child_.text
            Discriminacao_ = self.gds_validate_string(Discriminacao_, node, 'Discriminacao')
            self.Discriminacao = Discriminacao_
            # validate type tpDiscriminacao
            self.validate_tpDiscriminacao(self.Discriminacao)
        elif nodeName_ == 'TipoNFTS' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'TipoNFTS')
            self.TipoNFTS = ival_
            # validate type tpTipoNFTS
            self.validate_tpTipoNFTS(self.TipoNFTS)
        elif nodeName_ == 'Tomador':
            obj_ = tpTomador.factory(parent_object_=self)
            obj_.build(child_)
            self.Tomador = obj_
            obj_.original_tagname_ = 'Tomador'
        elif nodeName_ == 'Assinatura':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'Assinatura')
            else:
                bval_ = None
            self.Assinatura = bval_
            # validate type tpAssinatura
            self.validate_tpAssinatura(self.Assinatura)
        elif nodeName_ == 'CodigoCEI' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'CodigoCEI')
            self.CodigoCEI = ival_
            # validate type tpNumeroNFTS
            self.validate_tpNumeroNFTS(self.CodigoCEI)
        elif nodeName_ == 'MatriculaObra' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'MatriculaObra')
            self.MatriculaObra = ival_
            # validate type tpNumeroNFTS
            self.validate_tpNumeroNFTS(self.MatriculaObra)
# end class tpNFTS


class tpNFTSRetorno(GeneratedsSuper):
    """Tipo que representa uma NFTS de retorno."""
    subclass = None
    superclass = None
    def __init__(self, TipoDocumento=None, ChaveDocumento=None, ChaveNFTS=None, DataPrestacao=None, StatusNFTS=None, TributacaoNFTS=None, ValorServicos=None, ValorDeducoes=None, CodigoServico=None, CodigoSubItem=None, AliquotaServicos=None, ISSRetidoTomador=None, ISSRetidoIntermediario=None, Prestador=None, RegimeTributacao=None, DataPagamento=None, Discriminacao=None, Tomador=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.TipoDocumento = TipoDocumento
        self.validate_tpTipoDocumentoNFTS(self.TipoDocumento)
        self.ChaveDocumento = ChaveDocumento
        self.ChaveNFTS = ChaveNFTS
        if isinstance(DataPrestacao, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(DataPrestacao, '%Y-%m-%d').date()
        else:
            initvalue_ = DataPrestacao
        self.DataPrestacao = initvalue_
        self.StatusNFTS = StatusNFTS
        self.validate_tpStatusNFTS(self.StatusNFTS)
        self.TributacaoNFTS = TributacaoNFTS
        self.validate_tpTributacaoNFTS(self.TributacaoNFTS)
        self.ValorServicos = ValorServicos
        self.validate_tpValor(self.ValorServicos)
        self.ValorDeducoes = ValorDeducoes
        self.validate_tpValor(self.ValorDeducoes)
        self.CodigoServico = CodigoServico
        self.validate_tpCodigoServico(self.CodigoServico)
        self.CodigoSubItem = CodigoSubItem
        self.validate_tpCodigoSubitem(self.CodigoSubItem)
        self.AliquotaServicos = AliquotaServicos
        self.validate_tpAliquota(self.AliquotaServicos)
        self.ISSRetidoTomador = ISSRetidoTomador
        self.validate_tpISSRetidoTomador(self.ISSRetidoTomador)
        self.ISSRetidoIntermediario = ISSRetidoIntermediario
        self.validate_tpISSRetidoIntermediario(self.ISSRetidoIntermediario)
        self.Prestador = Prestador
        self.RegimeTributacao = RegimeTributacao
        self.validate_tpRegimeTributacao(self.RegimeTributacao)
        if isinstance(DataPagamento, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(DataPagamento, '%Y-%m-%d').date()
        else:
            initvalue_ = DataPagamento
        self.DataPagamento = initvalue_
        self.Discriminacao = Discriminacao
        self.validate_tpDiscriminacao(self.Discriminacao)
        self.Tomador = Tomador
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpNFTSRetorno)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpNFTSRetorno.subclass:
            return tpNFTSRetorno.subclass(*args_, **kwargs_)
        else:
            return tpNFTSRetorno(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_tpTipoDocumentoNFTS(self, value):
        # Validate type tpTipoDocumentoNFTS, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['01', '02', '03', '05']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tpTipoDocumentoNFTS' % {"value" : value.encode("utf-8")} )
            if len(value) > 2:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpTipoDocumentoNFTS' % {"value" : value.encode("utf-8")} )
            if len(value) < 2:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tpTipoDocumentoNFTS' % {"value" : value.encode("utf-8")} )
    def validate_tpStatusNFTS(self, value):
        # Validate type tpStatusNFTS, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['N', 'C']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tpStatusNFTS' % {"value" : value.encode("utf-8")} )
    def validate_tpTributacaoNFTS(self, value):
        # Validate type tpTributacaoNFTS, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['T', 'I', 'J']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tpTributacaoNFTS' % {"value" : value.encode("utf-8")} )
    def validate_tpValor(self, value):
        # Validate type tpValor, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on tpValor' % {"value" : value} )
            if len(str(value)) >= 15:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on tpValor' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_tpValor_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpValor_patterns_, ))
    validate_tpValor_patterns_ = [['^0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{0,2})?$']]
    def validate_tpCodigoServico(self, value):
        # Validate type tpCodigoServico, a restriction on xs:int.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_tpCodigoServico_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpCodigoServico_patterns_, ))
    validate_tpCodigoServico_patterns_ = [['^[0-9]{4,5}$']]
    def validate_tpCodigoSubitem(self, value):
        # Validate type tpCodigoSubitem, a restriction on xs:short.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_tpCodigoSubitem_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpCodigoSubitem_patterns_, ))
    validate_tpCodigoSubitem_patterns_ = [['^[0-9]{3,4}$']]
    def validate_tpAliquota(self, value):
        # Validate type tpAliquota, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on tpAliquota' % {"value" : value} )
            if len(str(value)) >= 5:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on tpAliquota' % {"value" : value} )
    def validate_tpISSRetidoTomador(self, value):
        # Validate type tpISSRetidoTomador, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_tpISSRetidoIntermediario(self, value):
        # Validate type tpISSRetidoIntermediario, a restriction on xs:boolean.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_tpRegimeTributacao(self, value):
        # Validate type tpRegimeTributacao, a restriction on xs:short.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_tpRegimeTributacao_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpRegimeTributacao_patterns_, ))
    validate_tpRegimeTributacao_patterns_ = [['^0|4|5$']]
    def validate_tpDiscriminacao(self, value):
        # Validate type tpDiscriminacao, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 2000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpDiscriminacao' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tpDiscriminacao' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.TipoDocumento is not None or
            self.ChaveDocumento is not None or
            self.ChaveNFTS is not None or
            self.DataPrestacao is not None or
            self.StatusNFTS is not None or
            self.TributacaoNFTS is not None or
            self.ValorServicos is not None or
            self.ValorDeducoes is not None or
            self.CodigoServico is not None or
            self.CodigoSubItem is not None or
            self.AliquotaServicos is not None or
            self.ISSRetidoTomador is not None or
            self.ISSRetidoIntermediario is not None or
            self.Prestador is not None or
            self.RegimeTributacao is not None or
            self.DataPagamento is not None or
            self.Discriminacao is not None or
            self.Tomador is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tpNFTSRetorno', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpNFTSRetorno')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='tpNFTSRetorno')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='tpNFTSRetorno', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='tpNFTSRetorno'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tpNFTSRetorno', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TipoDocumento is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTipoDocumento>%s</%sTipoDocumento>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TipoDocumento), input_name='TipoDocumento')), namespaceprefix_ , eol_))
        if self.ChaveDocumento is not None:
            self.ChaveDocumento.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ChaveDocumento', pretty_print=pretty_print)
        if self.ChaveNFTS is not None:
            self.ChaveNFTS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ChaveNFTS', pretty_print=pretty_print)
        if self.DataPrestacao is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDataPrestacao>%s</%sDataPrestacao>%s' % (namespaceprefix_ , self.gds_format_date(self.DataPrestacao, input_name='DataPrestacao'), namespaceprefix_ , eol_))
        if self.StatusNFTS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStatusNFTS>%s</%sStatusNFTS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.StatusNFTS), input_name='StatusNFTS')), namespaceprefix_ , eol_))
        if self.TributacaoNFTS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTributacaoNFTS>%s</%sTributacaoNFTS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.TributacaoNFTS), input_name='TributacaoNFTS')), namespaceprefix_ , eol_))
        if self.ValorServicos is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sValorServicos>%s</%sValorServicos>%s' % (namespaceprefix_ , self.gds_format_float(self.ValorServicos, input_name='ValorServicos'), namespaceprefix_ , eol_))
        if self.ValorDeducoes is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sValorDeducoes>%s</%sValorDeducoes>%s' % (namespaceprefix_ , self.gds_format_float(self.ValorDeducoes, input_name='ValorDeducoes'), namespaceprefix_ , eol_))
        if self.CodigoServico is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCodigoServico>%s</%sCodigoServico>%s' % (namespaceprefix_ , self.gds_format_integer(self.CodigoServico, input_name='CodigoServico'), namespaceprefix_ , eol_))
        if self.CodigoSubItem is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCodigoSubItem>%s</%sCodigoSubItem>%s' % (namespaceprefix_ , self.gds_format_integer(self.CodigoSubItem, input_name='CodigoSubItem'), namespaceprefix_ , eol_))
        if self.AliquotaServicos is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAliquotaServicos>%s</%sAliquotaServicos>%s' % (namespaceprefix_ , self.gds_format_float(self.AliquotaServicos, input_name='AliquotaServicos'), namespaceprefix_ , eol_))
        if self.ISSRetidoTomador is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sISSRetidoTomador>%s</%sISSRetidoTomador>%s' % (namespaceprefix_ , self.gds_format_boolean(self.ISSRetidoTomador, input_name='ISSRetidoTomador'), namespaceprefix_ , eol_))
        if self.ISSRetidoIntermediario is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sISSRetidoIntermediario>%s</%sISSRetidoIntermediario>%s' % (namespaceprefix_ , self.gds_format_boolean(self.ISSRetidoIntermediario, input_name='ISSRetidoIntermediario'), namespaceprefix_ , eol_))
        if self.Prestador is not None:
            self.Prestador.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Prestador', pretty_print=pretty_print)
        if self.RegimeTributacao is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRegimeTributacao>%s</%sRegimeTributacao>%s' % (namespaceprefix_ , self.gds_format_integer(self.RegimeTributacao, input_name='RegimeTributacao'), namespaceprefix_ , eol_))
        if self.DataPagamento is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDataPagamento>%s</%sDataPagamento>%s' % (namespaceprefix_ , self.gds_format_date(self.DataPagamento, input_name='DataPagamento'), namespaceprefix_ , eol_))
        if self.Discriminacao is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDiscriminacao>%s</%sDiscriminacao>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.Discriminacao), input_name='Discriminacao')), namespaceprefix_ , eol_))
        if self.Tomador is not None:
            self.Tomador.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Tomador', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TipoDocumento':
            TipoDocumento_ = child_.text
            TipoDocumento_ = self.gds_validate_string(TipoDocumento_, node, 'TipoDocumento')
            self.TipoDocumento = TipoDocumento_
            # validate type tpTipoDocumentoNFTS
            self.validate_tpTipoDocumentoNFTS(self.TipoDocumento)
        elif nodeName_ == 'ChaveDocumento':
            obj_ = tpChaveDocumento.factory(parent_object_=self)
            obj_.build(child_)
            self.ChaveDocumento = obj_
            obj_.original_tagname_ = 'ChaveDocumento'
        elif nodeName_ == 'ChaveNFTS':
            obj_ = tpChaveNFTS.factory(parent_object_=self)
            obj_.build(child_)
            self.ChaveNFTS = obj_
            obj_.original_tagname_ = 'ChaveNFTS'
        elif nodeName_ == 'DataPrestacao':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.DataPrestacao = dval_
        elif nodeName_ == 'StatusNFTS':
            StatusNFTS_ = child_.text
            StatusNFTS_ = self.gds_validate_string(StatusNFTS_, node, 'StatusNFTS')
            self.StatusNFTS = StatusNFTS_
            # validate type tpStatusNFTS
            self.validate_tpStatusNFTS(self.StatusNFTS)
        elif nodeName_ == 'TributacaoNFTS':
            TributacaoNFTS_ = child_.text
            TributacaoNFTS_ = self.gds_validate_string(TributacaoNFTS_, node, 'TributacaoNFTS')
            self.TributacaoNFTS = TributacaoNFTS_
            # validate type tpTributacaoNFTS
            self.validate_tpTributacaoNFTS(self.TributacaoNFTS)
        elif nodeName_ == 'ValorServicos' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'ValorServicos')
            self.ValorServicos = fval_
            # validate type tpValor
            self.validate_tpValor(self.ValorServicos)
        elif nodeName_ == 'ValorDeducoes' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'ValorDeducoes')
            self.ValorDeducoes = fval_
            # validate type tpValor
            self.validate_tpValor(self.ValorDeducoes)
        elif nodeName_ == 'CodigoServico' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'CodigoServico')
            self.CodigoServico = ival_
            # validate type tpCodigoServico
            self.validate_tpCodigoServico(self.CodigoServico)
        elif nodeName_ == 'CodigoSubItem' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'CodigoSubItem')
            self.CodigoSubItem = ival_
            # validate type tpCodigoSubitem
            self.validate_tpCodigoSubitem(self.CodigoSubItem)
        elif nodeName_ == 'AliquotaServicos' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AliquotaServicos')
            self.AliquotaServicos = fval_
            # validate type tpAliquota
            self.validate_tpAliquota(self.AliquotaServicos)
        elif nodeName_ == 'ISSRetidoTomador':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'ISSRetidoTomador')
            self.ISSRetidoTomador = ival_
            # validate type tpISSRetidoTomador
            self.validate_tpISSRetidoTomador(self.ISSRetidoTomador)
        elif nodeName_ == 'ISSRetidoIntermediario':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'ISSRetidoIntermediario')
            self.ISSRetidoIntermediario = ival_
            # validate type tpISSRetidoIntermediario
            self.validate_tpISSRetidoIntermediario(self.ISSRetidoIntermediario)
        elif nodeName_ == 'Prestador':
            obj_ = tpPrestador.factory(parent_object_=self)
            obj_.build(child_)
            self.Prestador = obj_
            obj_.original_tagname_ = 'Prestador'
        elif nodeName_ == 'RegimeTributacao' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'RegimeTributacao')
            self.RegimeTributacao = ival_
            # validate type tpRegimeTributacao
            self.validate_tpRegimeTributacao(self.RegimeTributacao)
        elif nodeName_ == 'DataPagamento':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.DataPagamento = dval_
        elif nodeName_ == 'Discriminacao':
            Discriminacao_ = child_.text
            Discriminacao_ = self.gds_validate_string(Discriminacao_, node, 'Discriminacao')
            self.Discriminacao = Discriminacao_
            # validate type tpDiscriminacao
            self.validate_tpDiscriminacao(self.Discriminacao)
        elif nodeName_ == 'Tomador':
            obj_ = tpTomador.factory(parent_object_=self)
            obj_.build(child_)
            self.Tomador = obj_
            obj_.original_tagname_ = 'Tomador'
# end class tpNFTSRetorno


class tpRetornoCPOM(GeneratedsSuper):
    """Lista de mensagens de retorno"""
    subclass = None
    superclass = None
    def __init__(self, Alerta=None, Erro=None, DetalheCPOM=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if Alerta is None:
            self.Alerta = []
        else:
            self.Alerta = Alerta
        if Erro is None:
            self.Erro = []
        else:
            self.Erro = Erro
        self.DetalheCPOM = DetalheCPOM
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpRetornoCPOM)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpRetornoCPOM.subclass:
            return tpRetornoCPOM.subclass(*args_, **kwargs_)
        else:
            return tpRetornoCPOM(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.Alerta or
            self.Erro or
            self.DetalheCPOM is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tpRetornoCPOM', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpRetornoCPOM')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='tpRetornoCPOM')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='tpRetornoCPOM', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='tpRetornoCPOM'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tpRetornoCPOM', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Alerta_ in self.Alerta:
            Alerta_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Alerta', pretty_print=pretty_print)
        for Erro_ in self.Erro:
            Erro_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Erro', pretty_print=pretty_print)
        if self.DetalheCPOM is not None:
            self.DetalheCPOM.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DetalheCPOM', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Alerta':
            obj_ = tpEvento.factory(parent_object_=self)
            obj_.build(child_)
            self.Alerta.append(obj_)
            obj_.original_tagname_ = 'Alerta'
        elif nodeName_ == 'Erro':
            obj_ = tpEvento.factory(parent_object_=self)
            obj_.build(child_)
            self.Erro.append(obj_)
            obj_.original_tagname_ = 'Erro'
        elif nodeName_ == 'DetalheCPOM':
            obj_ = tpDetalheCPOMRetorno.factory(parent_object_=self)
            obj_.build(child_)
            self.DetalheCPOM = obj_
            obj_.original_tagname_ = 'DetalheCPOM'
# end class tpRetornoCPOM


class tpDetalheCPOMRetorno(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CPFCNPJPrestador=None, SituacaoCPOM=None, Servicos=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.CPFCNPJPrestador = CPFCNPJPrestador
        self.SituacaoCPOM = SituacaoCPOM
        self.validate_tpSituacaoCPOM(self.SituacaoCPOM)
        if Servicos is None:
            self.Servicos = []
        else:
            self.Servicos = Servicos
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpDetalheCPOMRetorno)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpDetalheCPOMRetorno.subclass:
            return tpDetalheCPOMRetorno.subclass(*args_, **kwargs_)
        else:
            return tpDetalheCPOMRetorno(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_tpSituacaoCPOM(self, value):
        # Validate type tpSituacaoCPOM, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 200:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpSituacaoCPOM' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.CPFCNPJPrestador is not None or
            self.SituacaoCPOM is not None or
            self.Servicos
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tpDetalheCPOMRetorno', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpDetalheCPOMRetorno')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='tpDetalheCPOMRetorno')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='tpDetalheCPOMRetorno', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='tpDetalheCPOMRetorno'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tpDetalheCPOMRetorno', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CPFCNPJPrestador is not None:
            self.CPFCNPJPrestador.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CPFCNPJPrestador', pretty_print=pretty_print)
        if self.SituacaoCPOM is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSituacaoCPOM>%s</%sSituacaoCPOM>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SituacaoCPOM), input_name='SituacaoCPOM')), namespaceprefix_ , eol_))
        for Servicos_ in self.Servicos:
            Servicos_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Servicos', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CPFCNPJPrestador':
            obj_ = tpCPFCNPJ.factory(parent_object_=self)
            obj_.build(child_)
            self.CPFCNPJPrestador = obj_
            obj_.original_tagname_ = 'CPFCNPJPrestador'
        elif nodeName_ == 'SituacaoCPOM':
            SituacaoCPOM_ = child_.text
            SituacaoCPOM_ = self.gds_validate_string(SituacaoCPOM_, node, 'SituacaoCPOM')
            self.SituacaoCPOM = SituacaoCPOM_
            # validate type tpSituacaoCPOM
            self.validate_tpSituacaoCPOM(self.SituacaoCPOM)
        elif nodeName_ == 'Servicos':
            obj_ = tpServicos.factory(parent_object_=self)
            obj_.build(child_)
            self.Servicos.append(obj_)
            obj_.original_tagname_ = 'Servicos'
# end class tpDetalheCPOMRetorno


class tpServicos(GeneratedsSuper):
    """Código e descriçao da atividade"""
    subclass = None
    superclass = None
    def __init__(self, CodigoServico=None, DescricaoServico=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.CodigoServico = CodigoServico
        self.validate_tpCodigoServico(self.CodigoServico)
        self.DescricaoServico = DescricaoServico
        self.validate_tpDescricaoServico(self.DescricaoServico)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpServicos)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpServicos.subclass:
            return tpServicos.subclass(*args_, **kwargs_)
        else:
            return tpServicos(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_tpCodigoServico(self, value):
        # Validate type tpCodigoServico, a restriction on xs:int.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_tpCodigoServico_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpCodigoServico_patterns_, ))
    validate_tpCodigoServico_patterns_ = [['^[0-9]{4,5}$']]
    def validate_tpDescricaoServico(self, value):
        # Validate type tpDescricaoServico, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 250:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpDescricaoServico' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.CodigoServico is not None or
            self.DescricaoServico is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tpServicos', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpServicos')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='tpServicos')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='tpServicos', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='tpServicos'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tpServicos', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CodigoServico is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCodigoServico>%s</%sCodigoServico>%s' % (namespaceprefix_ , self.gds_format_integer(self.CodigoServico, input_name='CodigoServico'), namespaceprefix_ , eol_))
        if self.DescricaoServico is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDescricaoServico>%s</%sDescricaoServico>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DescricaoServico), input_name='DescricaoServico')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CodigoServico' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'CodigoServico')
            self.CodigoServico = ival_
            # validate type tpCodigoServico
            self.validate_tpCodigoServico(self.CodigoServico)
        elif nodeName_ == 'DescricaoServico':
            DescricaoServico_ = child_.text
            DescricaoServico_ = self.gds_validate_string(DescricaoServico_, node, 'DescricaoServico')
            self.DescricaoServico = DescricaoServico_
            # validate type tpDescricaoServico
            self.validate_tpDescricaoServico(self.DescricaoServico)
# end class tpServicos


class tpDetalheNFSERetorno(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CPFCNPJPrestador=None, ListaInscricaoMunicipal=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.CPFCNPJPrestador = CPFCNPJPrestador
        if ListaInscricaoMunicipal is None:
            self.ListaInscricaoMunicipal = []
        else:
            self.ListaInscricaoMunicipal = ListaInscricaoMunicipal
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpDetalheNFSERetorno)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpDetalheNFSERetorno.subclass:
            return tpDetalheNFSERetorno.subclass(*args_, **kwargs_)
        else:
            return tpDetalheNFSERetorno(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.CPFCNPJPrestador is not None or
            self.ListaInscricaoMunicipal
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tpDetalheNFSERetorno', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpDetalheNFSERetorno')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='tpDetalheNFSERetorno')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='tpDetalheNFSERetorno', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='tpDetalheNFSERetorno'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tpDetalheNFSERetorno', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CPFCNPJPrestador is not None:
            self.CPFCNPJPrestador.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CPFCNPJPrestador', pretty_print=pretty_print)
        for ListaInscricaoMunicipal_ in self.ListaInscricaoMunicipal:
            ListaInscricaoMunicipal_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ListaInscricaoMunicipal', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CPFCNPJPrestador':
            obj_ = tpCPFCNPJ.factory(parent_object_=self)
            obj_.build(child_)
            self.CPFCNPJPrestador = obj_
            obj_.original_tagname_ = 'CPFCNPJPrestador'
        elif nodeName_ == 'ListaInscricaoMunicipal':
            obj_ = tpListaInscricaoMunicipal.factory(parent_object_=self)
            obj_.build(child_)
            self.ListaInscricaoMunicipal.append(obj_)
            obj_.original_tagname_ = 'ListaInscricaoMunicipal'
# end class tpDetalheNFSERetorno


class tpListaInscricaoMunicipal(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, InscricaoMunicipal=None, SituacaoInscricaoMunicipal=None, SituacaoEmissaoNFSE=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.InscricaoMunicipal = InscricaoMunicipal
        self.validate_tpInscricaoMunicipal(self.InscricaoMunicipal)
        self.SituacaoInscricaoMunicipal = SituacaoInscricaoMunicipal
        self.validate_tpSituacaoInscricaoMunicipal(self.SituacaoInscricaoMunicipal)
        self.SituacaoEmissaoNFSE = SituacaoEmissaoNFSE
        self.validate_tpSituacaoEmissaoNFSE(self.SituacaoEmissaoNFSE)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpListaInscricaoMunicipal)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpListaInscricaoMunicipal.subclass:
            return tpListaInscricaoMunicipal.subclass(*args_, **kwargs_)
        else:
            return tpListaInscricaoMunicipal(*args_, **kwargs_)
    factory = staticmethod(factory)
    def validate_tpInscricaoMunicipal(self, value):
        # Validate type tpInscricaoMunicipal, a restriction on xs:long.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_tpInscricaoMunicipal_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpInscricaoMunicipal_patterns_, ))
    validate_tpInscricaoMunicipal_patterns_ = [['^[0-9]{8,8}$']]
    def validate_tpSituacaoInscricaoMunicipal(self, value):
        # Validate type tpSituacaoInscricaoMunicipal, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 200:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpSituacaoInscricaoMunicipal' % {"value" : value.encode("utf-8")} )
    def validate_tpSituacaoEmissaoNFSE(self, value):
        # Validate type tpSituacaoEmissaoNFSE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 200:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpSituacaoEmissaoNFSE' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.InscricaoMunicipal is not None or
            self.SituacaoInscricaoMunicipal is not None or
            self.SituacaoEmissaoNFSE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tpListaInscricaoMunicipal', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpListaInscricaoMunicipal')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='tpListaInscricaoMunicipal')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='tpListaInscricaoMunicipal', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='tpListaInscricaoMunicipal'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tpListaInscricaoMunicipal', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.InscricaoMunicipal is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sInscricaoMunicipal>%s</%sInscricaoMunicipal>%s' % (namespaceprefix_ , self.gds_format_integer(self.InscricaoMunicipal, input_name='InscricaoMunicipal'), namespaceprefix_ , eol_))
        if self.SituacaoInscricaoMunicipal is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSituacaoInscricaoMunicipal>%s</%sSituacaoInscricaoMunicipal>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SituacaoInscricaoMunicipal), input_name='SituacaoInscricaoMunicipal')), namespaceprefix_ , eol_))
        if self.SituacaoEmissaoNFSE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSituacaoEmissaoNFSE>%s</%sSituacaoEmissaoNFSE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SituacaoEmissaoNFSE), input_name='SituacaoEmissaoNFSE')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'InscricaoMunicipal' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'InscricaoMunicipal')
            self.InscricaoMunicipal = ival_
            # validate type tpInscricaoMunicipal
            self.validate_tpInscricaoMunicipal(self.InscricaoMunicipal)
        elif nodeName_ == 'SituacaoInscricaoMunicipal':
            SituacaoInscricaoMunicipal_ = child_.text
            SituacaoInscricaoMunicipal_ = self.gds_validate_string(SituacaoInscricaoMunicipal_, node, 'SituacaoInscricaoMunicipal')
            self.SituacaoInscricaoMunicipal = SituacaoInscricaoMunicipal_
            # validate type tpSituacaoInscricaoMunicipal
            self.validate_tpSituacaoInscricaoMunicipal(self.SituacaoInscricaoMunicipal)
        elif nodeName_ == 'SituacaoEmissaoNFSE':
            SituacaoEmissaoNFSE_ = child_.text
            SituacaoEmissaoNFSE_ = self.gds_validate_string(SituacaoEmissaoNFSE_, node, 'SituacaoEmissaoNFSE')
            self.SituacaoEmissaoNFSE = SituacaoEmissaoNFSE_
            # validate type tpSituacaoEmissaoNFSE
            self.validate_tpSituacaoEmissaoNFSE(self.SituacaoEmissaoNFSE)
# end class tpListaInscricaoMunicipal


class tpRetornoEmissaoNFSE(GeneratedsSuper):
    """Lista de mensagens de retorno"""
    subclass = None
    superclass = None
    def __init__(self, Alerta=None, Erro=None, DetalheEmissaoNFSE=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if Alerta is None:
            self.Alerta = []
        else:
            self.Alerta = Alerta
        if Erro is None:
            self.Erro = []
        else:
            self.Erro = Erro
        self.DetalheEmissaoNFSE = DetalheEmissaoNFSE
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tpRetornoEmissaoNFSE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tpRetornoEmissaoNFSE.subclass:
            return tpRetornoEmissaoNFSE.subclass(*args_, **kwargs_)
        else:
            return tpRetornoEmissaoNFSE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            self.Alerta or
            self.Erro or
            self.DetalheEmissaoNFSE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tpRetornoEmissaoNFSE', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tpRetornoEmissaoNFSE')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='tpRetornoEmissaoNFSE')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='tpRetornoEmissaoNFSE', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='tpRetornoEmissaoNFSE'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tpRetornoEmissaoNFSE', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Alerta_ in self.Alerta:
            Alerta_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Alerta', pretty_print=pretty_print)
        for Erro_ in self.Erro:
            Erro_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Erro', pretty_print=pretty_print)
        if self.DetalheEmissaoNFSE is not None:
            self.DetalheEmissaoNFSE.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DetalheEmissaoNFSE', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Alerta':
            obj_ = tpEvento.factory(parent_object_=self)
            obj_.build(child_)
            self.Alerta.append(obj_)
            obj_.original_tagname_ = 'Alerta'
        elif nodeName_ == 'Erro':
            obj_ = tpEvento.factory(parent_object_=self)
            obj_.build(child_)
            self.Erro.append(obj_)
            obj_.original_tagname_ = 'Erro'
        elif nodeName_ == 'DetalheEmissaoNFSE':
            obj_ = tpDetalheNFSERetorno.factory(parent_object_=self)
            obj_.build(child_)
            self.DetalheEmissaoNFSE = obj_
            obj_.original_tagname_ = 'DetalheEmissaoNFSE'
# end class tpRetornoEmissaoNFSE


GDSClassesMapping = {
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'tpEvento'
        rootClass = tpEvento
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:tipos="http://www.prefeitura.sp.gov.br/nfts/tipos"',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'tpEvento'
        rootClass = tpEvento
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'tpEvento'
        rootClass = tpEvento
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:tipos="http://www.prefeitura.sp.gov.br/nfts/tipos"')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'tpEvento'
        rootClass = tpEvento
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from TiposNFTS_v01 import *\n\n')
        sys.stdout.write('import TiposNFTS_v01 as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "tpCPFCNPJ",
    "tpCabecalho",
    "tpCabecalhoRetorno",
    "tpChaveDocumento",
    "tpChaveNFTS",
    "tpDetalheCPOMRetorno",
    "tpDetalheNFSERetorno",
    "tpEndereco",
    "tpEvento",
    "tpIdentificacaoDocumento",
    "tpIdentificacaoNFTS",
    "tpInformacoesLoteNFTS",
    "tpListaInscricaoMunicipal",
    "tpListaRetornoConsultaNFTS",
    "tpListaRetornoLote",
    "tpListaRetornoNFTS",
    "tpNFTS",
    "tpNFTSRetorno",
    "tpPrestador",
    "tpRemetente",
    "tpRemetente_ComCCM",
    "tpRetornoCPOM",
    "tpRetornoEmissaoNFSE",
    "tpServicos",
    "tpTomador"
]
